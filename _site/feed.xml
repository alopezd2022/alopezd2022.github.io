<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-11-30T16:20:27+01:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">PRACTICES</title><entry><title type="html">P3 Vending machine</title><link href="http://localhost:4000/2024/11/18/p3-maquina-expendedora.html" rel="alternate" type="text/html" title="P3 Vending machine" /><published>2024-11-18T00:00:00+01:00</published><updated>2024-11-18T00:00:00+01:00</updated><id>http://localhost:4000/2024/11/18/p3-maquina-expendedora</id><content type="html" xml:base="http://localhost:4000/2024/11/18/p3-maquina-expendedora.html"><![CDATA[<h2 id="description">Description</h2>
<p>La practica consiste en diseñar un controlador para una maquina expendedora que este basado en Arduino Uno. Para diseñar este controlador haremos uso de Arduino Threads, interrupciones, watchdog…</p>

<h2 id="hardware">Hardware</h2>

<p align="center">
  <img src="/assets/images/p3-empotrados/arduino.jpeg" alt="Arduino UNO" width="200" />
  <img src="/assets/images/p3-empotrados/lcd.webp" alt="LCD" width="200" />
  <img src="/assets/images/p3-empotrados/joystick.jpg" alt="Joystick" width="200" />
</p>
<p align="center">
  <b>Arduino UNO</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <b>LCD</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <b>Joystick</b>
</p>

<p align="center">
  <img src="/assets/images/p3-empotrados/dht11.jpeg" alt="Sensor DHT-11" width="200" />
  <img src="/assets/images/p3-empotrados/Hc-sr04.jpg" alt="Sensor HC-SR04" width="200" />
  <img src="/assets/images/p3-empotrados/boton.jpeg" alt="Botón" width="200" />
</p>
<p align="center">
  <b>Sensor DHT-11</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <b>HC-SR04</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <b>Botón</b>
</p>

<p align="center">
  <img src="/assets/images/p3-empotrados/leds.jpg" alt="LED Rojo" width="200" />
</p>
<p align="center">
  <b>LEDs</b> 
</p>

<p> </p>

<p>A partir de todos estos componentes obtenemos el siguiente esquema electrónico.</p>

<p align="center">
  <img src="/assets/images/p3-empotrados/Maquina_expendedora_bb.jpg" width="500" />
</p>

<h2 id="software">Software</h2>

<h3 id="clases">Clases</h3>
<h4 id="boot">Boot</h4>

<p>La clase boot es la clase encargada del arranque de la maquina expendedora. La clase Boot es una clase derivada de Thread que controla un pin led y una pantalla LCD, por lo tanto se ejecuta como “hilo independiente” que, una vez que acaba la secuencia de arranque, no se vuelve a ejecutar.</p>

<p>Al ejecutar se llama al metodo run la cual va alternando el estado de un pin y además muestra por la pantalla del lcd la cadena “CARGANDO…”.</p>

<p>Cuando el contador ha llegado a 3, se dejada de ejecutar el hilo y se remueve del controlador, ya que no volveremos a ejecutar dicha clase.</p>

<div style="text-align: center;">
    <video width="500" controls="">
      <source src="/assets/videos/p3-empotrados/boot.mp4" type="video/webm" />
      Tu navegador no soporta la reproducción de videos.
    </video>
</div>

<p> </p>

<h4 id="sensors">Sensors</h4>

<p>La clase sensor es la clase encargada de la lectura del sensor de humedad y temperatura y humedad. La clase es una clase derivada de Thread, por lo que se ejecuta como “hilo” cada 5 segundos y nunca es removido debido a que siempre queremos tener monitorizado la temperatura y humedad de nuestra maquina para prevenir de posibles desastres.</p>

<p>En ella encontramos la inicialización del sensor, dos métodos que obtienen los valores de temperatura y humedad respectivamente y dos métodos que muestran los valores por el lcd.</p>

<div style="text-align: center;">
    <video width="500" controls="">
      <source src="/assets/videos/p3-empotrados/sensors.mp4" type="video/webm" />
      Tu navegador no soporta la reproducción de videos.
    </video>
</div>

<p> </p>

<h4 id="menu">Menu</h4>

<p>La clase Menu es una clase que hereda de Thread y administra un menú de bebidas para una pantalla LCD controlada por un objeto LiquidCrystal. Contiene un arreglo de objetos Item (con nombre y precio), índices para la navegación del menú, y métodos para mostrar el menú en pantalla, cambiar precios y apagar la pantalla. El constructor inicializa el menú con 5 elementos predeterminados y configura el índice inicial en 0.</p>

<p>Los métodos permiten visualizar el elemento actual del menú, actualizar su precio y limpiar la pantalla LCD.</p>

<div style="text-align: center;">
    <video width="500" controls="">
      <source src="/assets/videos/p3-empotrados/menu.mp4" type="video/webm" />
      Tu navegador no soporta la reproducción de videos.
    </video>
</div>

<p> </p>

<h4 id="admin">Admin</h4>

<p>La clase Admin hereda de Thread y gestiona un menú administrativo para un dispositivo con pantalla LCD controlada por un objeto LiquidCrystal. Contiene un arreglo de cadenas con 4 opciones de menú y un índice para navegar entre ellas.</p>

<p>Incluye un método para mostrar la opción actual del menú en la pantalla y otro para apagar (limpiar) la pantalla. Proporciona una interfaz simple para administrar funcionalidades como sensores y configuración.</p>

<div style="text-align: center;">
    <video width="500" controls="">
      <source src="/assets/videos/p3-empotrados/admin.mp4" type="video/webm" />
      Tu navegador no soporta la reproducción de videos.
    </video>
</div>

<p> </p>

<h3 id="main">Main</h3>

<p>El main esta compuesto principalmente de las funciones :</p>

<ul>
  <li>
    <p><strong>setup</strong> en donde se inicializa el lcd, los pines para los leds y para las interrupciones, los intervalos de los threads en el controlador y el watchdog.</p>
  </li>
  <li>
    <p><strong>loop</strong> en donde se encuentra una maquina de estados finita.</p>
  </li>
</ul>

<p> </p>

<p align="center">
  <img src="/assets/images/p3-empotrados/state-machine.jpg" width="500" />
</p>

<p> </p>

<p>Como principales estados tenemos:</p>

<ul>
  <li>
    <p><strong>BOOT</strong>, estado que obtiene el contador de la clase BOOT y si ha llegado a 3 termina y transita al estado WAITING_CLIENT</p>
  </li>
  <li>
    <p><strong>WAITING_CLIENT</strong>, estado en el que el sensor de ultrasonidos recoge los valores de la distancia, en cuando hay un cliente a menos de un metro transita al estado IS_CLIENT</p>
  </li>
  <li>
    <p><strong>IS_CLIENT</strong>, estado que muestra durante 5 segundos la temperatura y humedad y transita al estado SHOW_MENU.</p>
  </li>
  <li>
    <p><strong>SHOW_MENU</strong>, estado que muestra el menú usando el método “showMenu” de la clase Menu, solo transita unicamente con la interrupción del botón del joystick.</p>
  </li>
  <li>
    <p><strong>PREPARE_PRODUCT</strong>, estado que simula la preparación del producto, en el se enciende progresivamente un led y muestra un mensaje por el lcd durnate un tiempo ramdon. Una vez finalizado muestra por el lcd que el producto esta listo y transita al estado WAITING_CLIENT.</p>
  </li>
</ul>

<div style="text-align: center;">
    <video width="500" controls="">
      <source src="/assets/videos/p3-empotrados/prepare-product.mp4" type="video/webm" />
      Tu navegador no soporta la reproducción de videos.
    </video>
</div>

<p> </p>

<p>En cualquier momento si queremos reiniciar y volver al estado WAITING_CLIENT se debe pulsar el botón en un rango de entre 2 y 3 segundos.</p>

<p>Con estos 5 estados tenemos el comportamiento a nivel de usuario de la maquina expendedora. Sin embargo, hay más comportamientos a nivel de administrados. Para transitar al estado de administrador se debe pulsar el botón durante 5 segundos.</p>

<ul>
  <li>
    <p><strong>ADMIN</strong>, estado que muestra el menú del administrados con las diferentes funcionalidades. Cada una se muestra como un sub-estado:</p>

    <ul>
      <li>
        <p><strong>SEE_TEMPERATURE</strong>, estado que muestra la temperatura y la humedad.</p>
      </li>
      <li>
        <p><strong>SEE_DISTANCE</strong>, estado que muestra los valores del sensor de ultrasonidos</p>
      </li>
      <li>
        <p><strong>COUNTER</strong>, estado que muestra el tiempo desde que se inicio.</p>
      </li>
      <li>
        <p><strong>CHANGE_PRICE</strong>, estado que cambia el precio de un producto, el cual tiene el sub-estado <strong>ASIGN_PRICE</strong> al cual solo transita unicamente con la interrupción del boton del joystick.</p>
      </li>
    </ul>
  </li>
</ul>

<p>Para transitar por los diferentes sub-estados al estado ADMIN unicamente se puede hacer mediante un movimiento del joystick en el eje X a la izquierda, una acción para “volver al menú”</p>

<p> </p>

<h4 id="watchdog">Watchdog</h4>

<p>Implementamos el watchdog como mecamismo de seguridad por si el sistema se queda bloqueado y no tiene el comportamiento deseado con un timer de 8 segundos.</p>

<p>Podemos observar su correcto funcionamiento ya que en el estado PREPARE_PRODUCT simulamos la preparación del producto con un delay random entre 4 y 8 segundos. Si no se resetea el watchdog, este va a reiniciar el sistema cuando el random de valor 8. En el siguiente video se puede observar lo comentado anteriormente.</p>

<div style="text-align: center;">
    <video width="500" controls="">
      <source src="/assets/videos/p3-empotrados/watchdog.mp4" type="video/webm" />
      Tu navegador no soporta la reproducción de videos.
    </video>
</div>
<p> </p>

<h3 id="final-video">Final video</h3>

<p>Video final con el comportamiento completo de la Maquina expendedora.</p>

<div style="text-align: center;">
    <video width="500" controls="">
      <source src="/assets/videos/p3-empotrados/complete-video.mp4" type="video/webm" />
      Tu navegador no soporta la reproducción de videos.
    </video>
</div>]]></content><author><name></name></author><category term="embedded-and-real-time-systems" /><summary type="html"><![CDATA[Description La practica consiste en diseñar un controlador para una maquina expendedora que este basado en Arduino Uno. Para diseñar este controlador haremos uso de Arduino Threads, interrupciones, watchdog…]]></summary></entry><entry><title type="html">P4 Global Navigation</title><link href="http://localhost:4000/2024/10/28/p4-global-navigation.html" rel="alternate" type="text/html" title="P4 Global Navigation" /><published>2024-10-28T00:00:00+01:00</published><updated>2024-10-28T00:00:00+01:00</updated><id>http://localhost:4000/2024/10/28/p4-global-navigation</id><content type="html" xml:base="http://localhost:4000/2024/10/28/p4-global-navigation.html"><![CDATA[<h2 id="description">Description</h2>

<p>The objective of this practice is to develop a global navigation algorithm. The user marks a point on the map, and the car must reach it by the shortest path.</p>

<h2 id="hardware">Hardware</h2>

<p>We only have a car without any sensors. The only information we have is its current position.</p>

<h2 id="software">Software</h2>

<h3 id="wave-front-algorthim">Wave Front Algorthim</h3>
<p>For the car’s navigation, we developed a search algorithm based on the Wave Front Algorithm. This approach generates a cost map by expanding from the final target, assigned a cost of 0, to the car, which receives a cost of <em>n</em>.</p>

<p>To create the cost map, successors of each point are assigned a value equal to <em>cost + 1</em>, while diagonal successors are assigned a value of <em>cost + 1.41</em> (representing the Euclidean distance).</p>

<div style="text-align: center;">
    <img src="/assets/images/p4/Captura desde 2024-11-18 19-01-14.png" alt="car" style="width: 300px" />
</div>

<p>Additionally, obstacles and positions near them are assigned an extra cost to ensure that these points are avoided during navigation.</p>

<p>Once the search and the filling of the cost grid are completed, we display the map based on the cost grid. However, since the costs exceed 255 (the maximum white color), we need to normalize it so that it is displayed in a range from 0 to 255 based on the highest cost.</p>

<div style="text-align: center;">
    <img src="/assets/images/p4/Captura desde 2024-11-26 11-44-16.png" alt="car" style="width: 300px" />
</div>

<h3 id="gradient-algorthim">Gradient algorthim</h3>

<p>Once the cost map is generated, we implement a gradient-based navigation algorithm. It works using potential fields: obstacles act as “potential walls” that the robot avoids, while the target serves as a “potential well” that attracts it. By combining these walls and wells, a downward slope path is created, and the robot simply follows it to reach its destination.</p>

<p> </p>

<h3 id="videos">Videos</h3>

<div style="text-align: center;">
    <video width="500" controls="">
      <source src="/assets/videos/p4/grabacion-de-pantalla-desde-2024-11-18-10-37-27_hUPDu7c6.webm" type="video/webm" />
      Tu navegador no soporta la reproducción de videos.
    </video>

&nbsp;

<div style="text-align: center;">
    <video width="500" controls="">
      <source src="/assets/videos/p4/grabacion-de-pantalla-desde-2024-11-18-10-44-35_0AQSLjZU.webm" type="video/webm" />
      Tu navegador no soporta la reproducción de videos.
    </video>

</div></div>]]></content><author><name></name></author><category term="mobile-robotics" /><summary type="html"><![CDATA[Description]]></summary></entry><entry><title type="html">P3 Obstacle Avoidance</title><link href="http://localhost:4000/2024/10/14/p3-obstacle_avoidance.html" rel="alternate" type="text/html" title="P3 Obstacle Avoidance" /><published>2024-10-14T00:00:00+02:00</published><updated>2024-10-14T00:00:00+02:00</updated><id>http://localhost:4000/2024/10/14/p3-obstacle_avoidance</id><content type="html" xml:base="http://localhost:4000/2024/10/14/p3-obstacle_avoidance.html"><![CDATA[<h2 id="description">Description</h2>

<p>The aim of this practice is to program a Formula 1 car which can avoid obstacle using Virtual Force Field system. In this case, we are going to develop a local navigating algorthims so that the car can move throw the circuit reaching the waypoints and avoiding the obstacles.</p>

<div style="text-align: center;">
    <img src="/assets/images/p3/coche.png" alt="car" style="width: 300px" />
</div>

<h2 id="hardware">Hardware</h2>

<p>The sensor is the laser LIDAR 180º and the actuators are as always the motor of the Formula 1 car.</p>

<h2 id="software">Software</h2>

<p>The strategy for this practice is develop a local navegation algorthim called VFF (Virtual Force Field). Is a navegation tecnice which allows our formula 1 car to move in a environment avoiding obstacles. Basically, the direction of the car is given by the attractive force generated by the position of the goal.</p>

<h3 id="vff">VFF</h3>
<p>The attractive vector is the vector drawn from the car’s position to the waypoint. This vector becomes very strong over long distances, so we will apply a force reducer.</p>

<p>The repulsive vector is the result of a weighted average of all the vectors drawn for all the angles of the laser. It is a weighted average because, in certain situations, such as very short distances, they do not have enough weight, and therefore the repulsive vector is not effective.</p>

<p>The resulting force should be the weighted average of both the attractive and repulsive vectors. Depending on the factors we assign to each, one vector will have more weight than the other. In this case, I found it more convenient to give greater weight to the repulsive vector so that it prioritizes avoiding obstacles.</p>

<h4 id="strategies-to-highlight">Strategies to highlight</h4>

<p>Reduce the size of the attractive vector, as at very high distances, it exerts too much force.</p>

<p>Increase the weight of small distances measured by the laser, so that when calculating the repulsive vector, these distances have more significance.</p>

<p>The linear velocity depends on the distance calculated as the magnitude of the resulting vector from the weighted average of both forces. This way, at short distances, the speed is reduced to allow for precise evasion.</p>

<p> </p>

<p>Here it is a video with the behavior of the formula 1 car.</p>

<div style="text-align: center;">
    <video width="500" controls="">
      <source src="/assets/videos/p3/cochevueltacompleta.webm" type="video/webm" />
      Tu navegador no soporta la reproducción de videos.
    </video>

</div>]]></content><author><name></name></author><category term="mobile-robotics" /><summary type="html"><![CDATA[Description]]></summary></entry><entry><title type="html">P2 Follow Line</title><link href="http://localhost:4000/2024/09/30/p2-follow-line.html" rel="alternate" type="text/html" title="P2 Follow Line" /><published>2024-09-30T00:00:00+02:00</published><updated>2024-09-30T00:00:00+02:00</updated><id>http://localhost:4000/2024/09/30/p2-follow-line</id><content type="html" xml:base="http://localhost:4000/2024/09/30/p2-follow-line.html"><![CDATA[<h2 id="description">Description</h2>
<p>The objective of this practice is to create a line follower that completes the circuit in the shortest possible time. In this case, the Formula 1 car follows a red line, and a PD controller will be used to control the angular and linear speed of the system.</p>

<h2 id="hardware">Hardware</h2>

<p>In this practice, we have a Formula 1 car equipped with a camera to follow the line. Therefore, the sensor is the camera, and the actuators are the motors of the Formula 1 car.</p>

<div style="text-align: center;">
    <img src="/assets/images/p2/Captura desde 2024-10-11 10-03-10.png" alt="HSV" style="width: 300px" />
</div>

<h2 id="software">Software</h2>

<h3 id="the-color-filtering">The color filtering</h3>

<p>The color filtering is done using HSV, a system in which I can adjust the color range (in this case, red), brightness, and saturation of the color. With these three parameters, I can accurately control all shades of red, avoiding any external elements such as the incidence of unexpected light.</p>

<div style="text-align: center;">
    <img src="/assets/images/p2/gyuw4.png" alt="HSV" style="width: 500px" />
</div>
<p> </p>
<h3 id="strategy-1">Strategy 1</h3>
<p>My first strategy was to take a bounding box from the image and count how many red pixels there were on both the left and right sides. The difference between them would represent the error of our system. However, this algorithm was neither precise nor robust, as it did not account for situations like curves, where both the left and right sides could have the same number of pixels.</p>

<div style="text-align: center;">
    <img src="/assets/images/p2/Captura desde 2024-10-11 09-34-36.png" alt="HSV" style="width: 350px" />
</div>

<p>Since this solution was not valid, I decided to increase the size of the bounding box, but that didn’t work either. I even tried using the entire image, but it still didn’t work due to the same problem.</p>

<p> </p>
<h3 id="strategy-2">Strategy 2</h3>

<p>The second strategy consists of taking two lines, one horizontal and one vertical. For each line, the average of the red pixels at that moment is calculated. The point obtained from these two averages is the point the car should always follow, meaning it represents where the car should always be.</p>

<p>Therefore, the error in our system is the difference between the fixed center point of the image (the intersection of the horizontal and vertical lines) and the point obtained from the average of the red pixels, which indicates where the car should be. However, I chose to divide the error into two distinct errors, as the difference along the horizontal axis indicates how much the car needs to turn, while the difference along the vertical axis indicates how much the car needs to move forward.</p>

<p>With two errors—one for angular velocity and one for linear velocity—we obtain two different controllers, making our strategy more precise and robust.</p>

<p>The blue point seen in the image represents the average position of the red pixels in both the horizontal and vertical directions, while the drawn cross is the point where the car should be.</p>

<p>Additionally, when the car loses the line, it turns to the last saved angle.</p>

<div style="text-align: center;">
    <img src="/assets/images/p2/Captura desde 2024-10-10 17-11-46.png" alt="HSV" style="width: 350px" />
</div>

<p> </p>
<h3 id="control">Control</h3>

<p>We are going to implement a PD controller, which is a feedback control mechanism that adjusts the output based on the error obtained from the difference between the desired value and the current value. This controller uses two components to reduce the error and achieve a better system response: the proportional part and the derivative part.</p>

<p>Proportional</p>

<p> 
The proportional part adjusts the output in proportion to the error; that is, if the error is large, the controller’s output will also be large.</p>

<p>It is calculated as the error multiplied by the proportional constant Kp. The constant determines the intensity of the system’s output relative to the error.</p>

<p>Derivative
 </p>

<p>The derivative part measures the change in the error over time. It assesses how quickly the error is changing and adjusts the output based on that change.</p>

<p>It is calculated as the derivative of the error multiplied by a derivative constant.</p>

<h3 id="result">Result</h3>

<p>After explaining the filtering, tracking algorithm, and control, the result is a Formula 1 car that completes the circuit in approximately 100 seconds.</p>

<div style="text-align: center;">
    <video width="400" controls="">
      <source src="/assets/videos/p2/cochesimple.mp4" type="video/mp4" />
      Tu navegador no soporta la reproducción de videos.
    </video>
</div>

<h2 id="conclusion">Conclusion</h2>

<p>Clearly, this algorithm is not the fastest, but in my opinion, it is quite robust and effective. I wasn’t looking for a fast car; I aimed for a car with control that has “smooth” movements, meaning it experiences minimal oscillation. As a final result, the car shows little oscillation and maintains control over both linear and angular velocity, which seems like a good outcome.</p>]]></content><author><name></name></author><category term="mobile-robotics" /><summary type="html"><![CDATA[Description The objective of this practice is to create a line follower that completes the circuit in the shortest possible time. In this case, the Formula 1 car follows a red line, and a PD controller will be used to control the angular and linear speed of the system.]]></summary></entry><entry><title type="html">P1 Vacuum Cleaner</title><link href="http://localhost:4000/2024/09/16/p1-vacuum-cleaner.html" rel="alternate" type="text/html" title="P1 Vacuum Cleaner" /><published>2024-09-16T00:00:00+02:00</published><updated>2024-09-16T00:00:00+02:00</updated><id>http://localhost:4000/2024/09/16/p1-vacuum-cleaner</id><content type="html" xml:base="http://localhost:4000/2024/09/16/p1-vacuum-cleaner.html"><![CDATA[<h2 id="description">Description</h2>
<p> 
The goal is to develop a software for a vacuum cleaner robot. The robot must explore the most surface of the house.
For that, we only have the laser sensor and the bumper; therefore the software for this application is not quite difficult.</p>

<p>Remember that the vacuum cleaner cannot make use of localization algorithms.</p>

<p> </p>
<h2 id="hardware">Hardware</h2>

<div style="text-align: center;">
    <img src="/assets/images/Captura desde 2024-09-27 15-52-32.png" alt="Aspiradora Robot" />
</div>
<p> </p>
<ul>
  <li>
    <p>As actuators, we have the wheels of the robot, which can move in a linear and angular way.</p>
  </li>
  <li>
    <p>As sensors, we have a laser LIDAR 180º and a bumper.</p>
  </li>
</ul>

<p> </p>
<h2 id="software">Software</h2>
<p> 
The system must be reactive, so that I have developed a state machine whose behavior is described below.
 </p>
<div style="text-align: center;">
    <img src="/assets/images/p1-vacuum-cleaner.drawio.png" alt="Aspiradora Robot" />
</div>
<p> 
As you can see, my solution to the problem is a reactive and random algorithm, in which the movements in the “Turn” and “Forward” states are random. However, when the robot collides and activates the bumper state, it first moves slightly backward and then has two options. One is “Turn max angle”, which, as the name suggests, uses the laser to find the direction with the greatest detected distance and turns towards it accordingly. The other option is “Turn half angle”, where the robot rotates on its axis and changes direction by turning approximately 180º.</p>

<h3 id="videos">Videos</h3>
<p> 
In this video, you can see the robot’s operation. The video is at 4x speed, so it will appear accelerated.
 </p>
<div style="text-align: center;">
    <video width="600" controls="">
      <source src="/assets/videos/Video-completo.webm" type="video/webm" />
      Tu navegador no soporta la reproducción de videos.
    </video>
</div>
<p> 
In this other video, you can see how the robot exits the room, avoiding getting trapped inside it.</p>
<div style="text-align: center;">
    <video width="400" controls="">
      <source src="/assets/videos/Video-habitaci%C3%B3n.webm" type="video/webm" />
      Tu navegador no soporta la reproducción de videos.
    </video>
</div>
<p> </p>

<h2 id="conclusion">Conclusion</h2>
<p>At first, when the practice was presented to us, I thought about creating complex software using geometric shapes that would cover the largest possible area. However, in reality, developing complex software to perform these tasks did not seem appropriate for this practice, as we had to develop a reactive algorithm. Therefore, I ultimately opted for a random algorithm that provides random movements and is constantly checking the sensors, which is where the reactivity comes from. This resulted in a simple algorithm for a sensory cleaning robot.</p>]]></content><author><name></name></author><category term="mobile-robotics" /><summary type="html"><![CDATA[Description   The goal is to develop a software for a vacuum cleaner robot. The robot must explore the most surface of the house. For that, we only have the laser sensor and the bumper; therefore the software for this application is not quite difficult.]]></summary></entry></feed>