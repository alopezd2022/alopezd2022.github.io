<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-10-25T18:23:44+02:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">MOBILE ROBOTICS PRACTICES</title><entry><title type="html">P3 Obstacle Avoidance</title><link href="http://localhost:4000/2024/10/14/p3-obstacle_avoidance.html" rel="alternate" type="text/html" title="P3 Obstacle Avoidance" /><published>2024-10-14T00:00:00+02:00</published><updated>2024-10-14T00:00:00+02:00</updated><id>http://localhost:4000/2024/10/14/p3-obstacle_avoidance</id><content type="html" xml:base="http://localhost:4000/2024/10/14/p3-obstacle_avoidance.html"><![CDATA[<h2 id="description">Description</h2>

<p>The aim of this practice is to program a Formula 1 car which can avoid obstacle using Virtual Force Field system. In this case, we are going to develop a local navigating algorthims so that the car can move throw the circuit reaching the waypoints and avoiding the obstacles.</p>

<div style="text-align: center;">
    <img src="/assets/images/p3/Captura desde 2024-10-14 10-40-43.png" alt="car" style="width: 300px" />
</div>

<h2 id="hardware">Hardware</h2>

<p>The sensor is the laser LIDAR 180º and the actuators are as always the motor of the Formula 1 car.</p>

<h2 id="software">Software</h2>

<p>The strategy for this practice is develop a local navegation algorthim called VFF (Virtual Force Field). Is a navegation tecnice which allows our formula 1 car to move in a environment avoiding obstacles. Basically, the direction of the car is given by the attractive force generated by the position of the goal.</p>

<h3 id="vff">VFF</h3>
<p>The attractive vector is the vector drawn from the car’s position to the waypoint. This vector becomes very strong over long distances, so we will apply a force reducer.</p>

<p>The repulsive vector is the result of a weighted average of all the vectors drawn for all the angles of the laser. It is a weighted average because, in certain situations, such as very short distances, they do not have enough weight, and therefore the repulsive vector is not effective.</p>

<p>The resulting force should be the weighted average of both the attractive and repulsive vectors. Depending on the factors we assign to each, one vector will have more weight than the other. In this case, I found it more convenient to give greater weight to the repulsive vector so that it prioritizes avoiding obstacles.</p>

<h2 id="conclusion">Conclusion</h2>]]></content><author><name></name></author><summary type="html"><![CDATA[Description]]></summary></entry><entry><title type="html">P2 Follow Line</title><link href="http://localhost:4000/2024/09/30/p2-follow-line.html" rel="alternate" type="text/html" title="P2 Follow Line" /><published>2024-09-30T00:00:00+02:00</published><updated>2024-09-30T00:00:00+02:00</updated><id>http://localhost:4000/2024/09/30/p2-follow-line</id><content type="html" xml:base="http://localhost:4000/2024/09/30/p2-follow-line.html"><![CDATA[<h2 id="description">Description</h2>
<p>The objective of this practice is to create a line follower that completes the circuit in the shortest possible time. In this case, the Formula 1 car follows a red line, and a PD controller will be used to control the angular and linear speed of the system.</p>

<h2 id="hardware">Hardware</h2>

<p>In this practice, we have a Formula 1 car equipped with a camera to follow the line. Therefore, the sensor is the camera, and the actuators are the motors of the Formula 1 car.</p>

<div style="text-align: center;">
    <img src="/assets/images/p2/Captura desde 2024-10-11 10-03-10.png" alt="HSV" style="width: 300px" />
</div>

<h2 id="software">Software</h2>

<h3 id="the-color-filtering">The color filtering</h3>

<p>The color filtering is done using HSV, a system in which I can adjust the color range (in this case, red), brightness, and saturation of the color. With these three parameters, I can accurately control all shades of red, avoiding any external elements such as the incidence of unexpected light.</p>

<div style="text-align: center;">
    <img src="/assets/images/p2/gyuw4.png" alt="HSV" style="width: 500px" />
</div>
<p> </p>
<h3 id="strategy-1">Strategy 1</h3>
<p>My first strategy was to take a bounding box from the image and count how many red pixels there were on both the left and right sides. The difference between them would represent the error of our system. However, this algorithm was neither precise nor robust, as it did not account for situations like curves, where both the left and right sides could have the same number of pixels.</p>

<div style="text-align: center;">
    <img src="/assets/images/p2/Captura desde 2024-10-11 09-34-36.png" alt="HSV" style="width: 350px" />
</div>

<p>Since this solution was not valid, I decided to increase the size of the bounding box, but that didn’t work either. I even tried using the entire image, but it still didn’t work due to the same problem.</p>

<p> </p>
<h3 id="strategy-2">Strategy 2</h3>

<p>The second strategy consists of taking two lines, one horizontal and one vertical. For each line, the average of the red pixels at that moment is calculated. The point obtained from these two averages is the point the car should always follow, meaning it represents where the car should always be.</p>

<p>Therefore, the error in our system is the difference between the fixed center point of the image (the intersection of the horizontal and vertical lines) and the point obtained from the average of the red pixels, which indicates where the car should be. However, I chose to divide the error into two distinct errors, as the difference along the horizontal axis indicates how much the car needs to turn, while the difference along the vertical axis indicates how much the car needs to move forward.</p>

<p>With two errors—one for angular velocity and one for linear velocity—we obtain two different controllers, making our strategy more precise and robust.</p>

<p>The blue point seen in the image represents the average position of the red pixels in both the horizontal and vertical directions, while the drawn cross is the point where the car should be.</p>

<p>Additionally, when the car loses the line, it turns to the last saved angle.</p>

<div style="text-align: center;">
    <img src="/assets/images/p2/Captura desde 2024-10-10 17-11-46.png" alt="HSV" style="width: 350px" />
</div>

<p> </p>
<h3 id="control">Control</h3>

<p>We are going to implement a PD controller, which is a feedback control mechanism that adjusts the output based on the error obtained from the difference between the desired value and the current value. This controller uses two components to reduce the error and achieve a better system response: the proportional part and the derivative part.</p>

<p>Proportional</p>

<p> 
The proportional part adjusts the output in proportion to the error; that is, if the error is large, the controller’s output will also be large.</p>

<p>It is calculated as the error multiplied by the proportional constant Kp. The constant determines the intensity of the system’s output relative to the error.</p>

<p>Derivative
 </p>

<p>The derivative part measures the change in the error over time. It assesses how quickly the error is changing and adjusts the output based on that change.</p>

<p>It is calculated as the derivative of the error multiplied by a derivative constant.</p>

<h3 id="result">Result</h3>

<p>After explaining the filtering, tracking algorithm, and control, the result is a Formula 1 car that completes the circuit in approximately 100 seconds.</p>

<div style="text-align: center;">
    <video width="400" controls="">
      <source src="/assets/videos/p2/cochesimple.mp4" type="video/mp4" />
      Tu navegador no soporta la reproducción de videos.
    </video>
</div>

<h2 id="conclusion">Conclusion</h2>

<p>Clearly, this algorithm is not the fastest, but in my opinion, it is quite robust and effective. I wasn’t looking for a fast car; I aimed for a car with control that has “smooth” movements, meaning it experiences minimal oscillation. As a final result, the car shows little oscillation and maintains control over both linear and angular velocity, which seems like a good outcome.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Description The objective of this practice is to create a line follower that completes the circuit in the shortest possible time. In this case, the Formula 1 car follows a red line, and a PD controller will be used to control the angular and linear speed of the system.]]></summary></entry><entry><title type="html">P1 Vacuum Cleaner</title><link href="http://localhost:4000/2024/09/16/p1-vacuum-cleaner.html" rel="alternate" type="text/html" title="P1 Vacuum Cleaner" /><published>2024-09-16T00:00:00+02:00</published><updated>2024-09-16T00:00:00+02:00</updated><id>http://localhost:4000/2024/09/16/p1-vacuum-cleaner</id><content type="html" xml:base="http://localhost:4000/2024/09/16/p1-vacuum-cleaner.html"><![CDATA[<h2 id="description">Description</h2>
<p> 
The goal is to develop a software for a vacuum cleaner robot. The robot must explore the most surface of the house.
For that, we only have the laser sensor and the bumper; therefore the software for this application is not quite difficult.</p>

<p>Remember that the vacuum cleaner cannot make use of localization algorithms.</p>

<p> </p>
<h2 id="hardware">Hardware</h2>

<div style="text-align: center;">
    <img src="/assets/images/Captura desde 2024-09-27 15-52-32.png" alt="Aspiradora Robot" />
</div>
<p> </p>
<ul>
  <li>
    <p>As actuators, we have the wheels of the robot, which can move in a linear and angular way.</p>
  </li>
  <li>
    <p>As sensors, we have a laser LIDAR 180º and a bumper.</p>
  </li>
</ul>

<p> </p>
<h2 id="software">Software</h2>
<p> 
The system must be reactive, so that I have developed a state machine whose behavior is described below.
 </p>
<div style="text-align: center;">
    <img src="/assets/images/p1-vacuum-cleaner.drawio.png" alt="Aspiradora Robot" />
</div>
<p> 
As you can see, my solution to the problem is a reactive and random algorithm, in which the movements in the “Turn” and “Forward” states are random. However, when the robot collides and activates the bumper state, it first moves slightly backward and then has two options. One is “Turn max angle”, which, as the name suggests, uses the laser to find the direction with the greatest detected distance and turns towards it accordingly. The other option is “Turn half angle”, where the robot rotates on its axis and changes direction by turning approximately 180º.</p>

<h3 id="videos">Videos</h3>
<p> 
In this video, you can see the robot’s operation. The video is at 4x speed, so it will appear accelerated.
 </p>
<div style="text-align: center;">
    <video width="600" controls="">
      <source src="/assets/videos/Video-completo.webm" type="video/webm" />
      Tu navegador no soporta la reproducción de videos.
    </video>
</div>
<p> 
In this other video, you can see how the robot exits the room, avoiding getting trapped inside it.</p>
<div style="text-align: center;">
    <video width="400" controls="">
      <source src="/assets/videos/Video-habitaci%C3%B3n.webm" type="video/webm" />
      Tu navegador no soporta la reproducción de videos.
    </video>
</div>
<p> </p>

<h2 id="conclusion">Conclusion</h2>
<p>At first, when the practice was presented to us, I thought about creating complex software using geometric shapes that would cover the largest possible area. However, in reality, developing complex software to perform these tasks did not seem appropriate for this practice, as we had to develop a reactive algorithm. Therefore, I ultimately opted for a random algorithm that provides random movements and is constantly checking the sensors, which is where the reactivity comes from. This resulted in a simple algorithm for a sensory cleaning robot.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Description   The goal is to develop a software for a vacuum cleaner robot. The robot must explore the most surface of the house. For that, we only have the laser sensor and the bumper; therefore the software for this application is not quite difficult.]]></summary></entry></feed>